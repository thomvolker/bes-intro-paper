install.packages("tinytex")
tinytex::install_tinytex()
getwd()
tinytex::xelatex("../bes_intro_paper")
tinytex::xelatex("../bes_intro_paper.tex")
tinytex::lualatex("../bes_intro_paper.tex")
tinytex::reinstall_tinytex()
tinytex::reinstall_tinytex()
tinytex::install_tinytex()
tinytex::reinstall_tinytex()
tinytex::xelatex("../bes_intro_paper.tex")
tinytex::check_installed("biblatex")
setwd("..")
getwd()
setwd("C:/Users/5868777/surfdrive/Shared/BES intro paper")
set.seed(123)
df <- tibble::tibble(x1 = rnorm(100),
x2 = rnorm(100),
x3 = rnorm(100),
y  = x1 + x2 + x3 + rnorm(100, 0, 3))
fit <- lm(y ~ x1 + x2 + x3, df)
summary(fit)
library(bain)
install.packages("bain")
library(bain)
bain(fit, hypothesis = "x1=x3 < x2")
install.packages("BFpack")
library(BFpack)
BF(fit, hypothesis = "x1 = x3 < x2")
BFobj <- BF(fit, hypothesis = "x1 = x3 < x2")
BFobj$BFmatrix_confirmatory
BFobj$BFtu_exploratory
BFobj %>% summary()
summary(BFobj)
bain(fit, hypothesis = "x1=x3 < x2")
bain(fit, hypothesis = "x1=x3")
matrix(rnorm(30), ncol = 3)
matrix(rnorm(30), ncol = 3) %*% c(1,2,3)
matrix(rnorm(30), ncol = 3) %*% matrix(c(1,2,3))
matrix(c(123))
matrix(c(1,2,3))
X <- rnorm(30, ncol = 3)
X <- matrix(rnorm(30), ncol = 3)
X %*% c(1,2,3)
X %*% matrix(c(1,2,3))
x <- rnorm(10)
exp(x) / (1 + exp(x))
1 / (1 + exp(-x))
pnorm(rnorm(10))
pnorm(x)
knitr::opts_chunk$set(echo = TRUE)
table_coefs <- function(R2, models, ratio, rho) {
coef <- coefs(R2, ratio, rho, models) %>% sprintf(fmt = "%.3f") %>% t %>% as_tibble
coef
}
betas <- expand_grid(R2, models) %>%
mutate(coefs = map2(R2, models, ~table_coefs(.x, .y, ratio, cormat))) %>%
unnest(cols = c(coefs)) %>%
mutate(V0 = rep(" ", nrow(.))) %>%
pivot_wider(names_from = models,
values_from = c("V0", "V1", "V2", "V3", "V4", "V5", "V6")) %>%
mutate(R2 = as.character(R2)) %>%
select(R2,
map(paste0(c("normal", "logit", "probit")),
~paste0("V", c(0, 1, 2, 5, 6), "_", .x)) %>% unlist())
## Set seed
set.seed(123)
# Load packages
library(tidyverse)
library(magrittr)
library(furrr)
library(BFpack)
library(Rcpp)
library(RcppArmadillo)
# devtools::build("DataCpp")
# devtools::install("DataCpp")
library(DataCpp)
source("functions.R")
## Number of simulations
nsim <- 1000
## Sample sizes
n <- 50 * 2^{0:4}
## Models
models <- c("normal", "logit", "probit")
## r2 of the regression model
r2 <- c(.02, .09, .25)
## Specify relative importance of the regression coefficients
ratio_beta <- c(1,1,1,2,3)
## Specify the bivariate correlations between predictors
pcor <- c(0.3)
table_coefs <- function(R2, models, ratio, rho) {
coef <- coefs(R2, ratio, rho, models) %>% sprintf(fmt = "%.3f") %>% t %>% as_tibble
coef
}
betas <- expand_grid(R2, models) %>%
mutate(coefs = map2(R2, models, ~table_coefs(.x, .y, ratio, cormat))) %>%
unnest(cols = c(coefs)) %>%
mutate(V0 = rep(" ", nrow(.))) %>%
pivot_wider(names_from = models,
values_from = c("V0", "V1", "V2", "V3", "V4", "V5", "V6")) %>%
mutate(R2 = as.character(R2)) %>%
select(R2,
map(paste0(c("normal", "logit", "probit")),
~paste0("V", c(0, 1, 2, 5, 6), "_", .x)) %>% unlist())
expand_grid(r2, models) %>%
mutate(coefs = map2(r2, models,
~table_coefs(.x,
.y,
ratio_beta,
cormat(rho, length(ratio_beta)))))
expand_grid(r2, models) %>%
mutate(coefs = map2(r2, models,
~table_coefs(.x,
.y,
ratio_beta,
cormat(pcor, length(ratio_beta)))))
betas <- expand_grid(r2, models) %>%
mutate(coefs = map2(r2, models,
~table_coefs(.x,
.y,
ratio_beta,
cormat(pcor, length(ratio_beta))))) %>%
unnest(cols = c(coefs)) %>%
mutate(V0 = rep(" ", nrow(.))) %>%
pivot_wider(names_from = models,
values_from = c("V0", "V1", "V2", "V3", "V4", "V5", "V6")) %>%
mutate(r2 = as.character(r2)) %>%
select(r2,
map(paste0(c("normal", "logit", "probit")),
~paste0("V", c(0, 1, 2, 5, 6), "_", .x)) %>% unlist())
expand_grid(r2, models) %>%
mutate(coefs = map2(r2, models,
~table_coefs(.x,
.y,
ratio_beta,
cormat(pcor, length(ratio_beta))))) %>%
unnest(cols = c(coefs)) %>%
mutate(V0 = rep(" ", nrow(.))) %>%
pivot_wider(names_from = models,
values_from = c("V0", "V1", "V2", "V3", "V4", "V5"))
betas <- expand_grid(r2, models) %>%
mutate(coefs = map2(r2, models,
~table_coefs(.x,
.y,
ratio_beta,
cormat(pcor, length(ratio_beta))))) %>%
unnest(cols = c(coefs)) %>%
mutate(V0 = rep(" ", nrow(.))) %>%
pivot_wider(names_from = models,
values_from = c("V0", "V1", "V2", "V3", "V4", "V5")) %>%
mutate(r2 = as.character(r2)) %>%
select(r2,
map(paste0(c("normal", "logit", "probit")),
~paste0("V", c(0, 1, 4, 5), "_", .x)) %>% unlist())
beta_names <- c(" ", rep(c(" ",
"$\\beta_{1, 2, 3}$",
"$\\beta_4$",
"$\\beta_5$"), 3)) %>%
t %>%
as_tibble
names(beta_names) <- colnames(betas)
betas <- bind_rows(beta_names, betas)
addtorow <- list()
addtorow$pos <- list(0)
addtorow$command <- c("$R^2$ & & \\multicolumn{4}{c}{OLS} & & \\multicolumn{4}{c}{Logistic} & & \\multicolumn{4}{c}{Probit} \\\\\n")
xtable(betas,
auto = TRUE,
caption = c("Population-level regression coefficients for ordinary least squares (OLS), logistic and probit regression, given effect sizes of $R^2 \\in \\{0.02, 0.09, 0.25\\}$."),
label = c("tab:coefs")) %>%
print(sanitize.text.function = function(x) {x},
include.rownames = FALSE,
include.colnames = FALSE,
add.to.row = addtorow,
booktabs = TRUE,
hline.after = c(-1, 0, 1, nrow(.)),
scalebox = 0.8,
caption.placement = "top",
table.placement = "t")
library(xtable)
xtable(betas,
auto = TRUE,
caption = c("Population-level regression coefficients for ordinary least squares (OLS), logistic and probit regression, given effect sizes of $R^2 \\in \\{0.02, 0.09, 0.25\\}$."),
label = c("tab:coefs")) %>%
print(sanitize.text.function = function(x) {x},
include.rownames = FALSE,
include.colnames = FALSE,
add.to.row = addtorow,
booktabs = TRUE,
hline.after = c(-1, 0, 1, nrow(.)),
scalebox = 0.8,
caption.placement = "top",
table.placement = "t")
addtorow$command <- c("$R^2$ & & \\multicolumn{3}{c}{OLS} & & \\multicolumn{3}{c}{Logistic} & & \\multicolumn{3}{c}{Probit} \\\\\n")
xtable(betas,
auto = TRUE,
caption = c("Population-level regression coefficients for ordinary least squares (OLS), logistic and probit regression, given effect sizes of $R^2 \\in \\{0.02, 0.09, 0.25\\}$."),
label = c("tab:coefs")) %>%
print(sanitize.text.function = function(x) {x},
include.rownames = FALSE,
include.colnames = FALSE,
add.to.row = addtorow,
booktabs = TRUE,
hline.after = c(-1, 0, 1, nrow(.)),
scalebox = 0.8,
caption.placement = "top",
table.placement = "t")
xtable(betas,
auto = TRUE,
caption = c("Population-level regression coefficients for ordinary least squares (OLS), logistic and probit regression, given effect sizes of $R^2 \\in \\{0.02, 0.09, 0.25\\}$."),
label = c("coefs")) %>%
print(sanitize.text.function = function(x) {x},
include.rownames = FALSE,
include.colnames = FALSE,
add.to.row = addtorow,
booktabs = TRUE,
hline.after = c(-1, 0, 1, nrow(.)),
scalebox = 0.8,
caption.placement = "top",
table.placement = "t")
xtable(betas,
auto = TRUE,
caption = c("Population-level regression coefficients for ordinary least squares (OLS), logistic and probit regression, given effect sizes of $R^2 \\in \\{0.02, 0.09, 0.25\\}$."),
label = c("coefs")) %>%
print(sanitize.text.function = function(x) {x},
include.rownames = FALSE,
include.colnames = FALSE,
add.to.row = addtorow,
booktabs = TRUE,
hline.after = c(-1, 0, 1, nrow(.)),
caption.placement = "top",
table.placement = "t")
pbeta(0.6, 12, 8)
pbeta(0.6, 120, 80)
?BFpack::BF()
getwd()
setwd("..")
getwd()
tinytex::xelatex("BES_intro_paper.tex")
install.packages("igraph")
library(igraph)
pop_names <- c("Noah", "Sem", "Sam", "Liam", "Lucas",
"Daan", "Finn", "Levi", "Luuk", "Mees",
"Emma", "Julia", "Mila", "Tess", "Sophie",
"ZoÃ«", "Sara", "Nora", "Yara", "Eva")
## Specify who knows who (probably not very realistic, as people choose each
## other independently, so if I nominate you, the probability that you also
## nominate me is as large as the probability that you nominate anyone else)
know <- sapply(pop_names, function(x) {
sample(pop_names[!pop_names %in% x], size = sample(0:5, 1))
})
know
know
## Exclude two persons that you do not talk frequently to
talk_freq <- sapply(know, function(x) sample(x, max(0, length(x) - 2)))
talk_freq
## Specify initial vertices (only ID and how many persons you know)
vrtcs <- data.frame(ID = pop_names,
know_many = sapply(know, length))
vrtcs
tibble(names = pop_names,
know = know) %>%
unnest(know)
tibble(names = pop_names,
know = know) %>%
tidyr::unnest(know)
library(tidyverse)
tibble(names = pop_names,
know = know) %>%
unnest(know)
## Specify initial vertices (only ID and how many persons you know)
vrtcs <- data.frame(ID = pop_names,
know_many = sapply(know, length))
## Generate a multivariate normal distribution with a correlation of 0.2
## between the share questions (we translate this to specific values later)
share <- MASS::mvrnorm(length(pop_names),
mu = c(0,0,0),
Sigma = matrix(c(1,0.2,0.2,
0.2,1,0.2,
0.2,0.2,1), nrow=3, byrow = TRUE))
## Do the same for the "try" questions
try <- MASS::mvrnorm(length(pop_names),
mu = c(0,0,0),
Sigma = matrix(c(1,0.2,0.2,
0.2,1,0.2,
0.2,0.2,1), nrow=3, byrow = TRUE))
## Specify the names for these questions
colnames(share) <- c("shareYT", "shareVeg", "sharePap")
colnames(try) <- c("tryYT", "tryVeg", "tryPap")
## Break the standard normal values down into integers representing groups
## of about equal sizes.
vrtcs <- bind_cols(vrtcs,
lapply(data.frame(share),
function(x) as.numeric(cut(x, breaks = 5))),
lapply(data.frame(try),
function(x) as.numeric(cut(x, breaks = 5))))
## Make a graph of the data
graph <- tibble(names = pop_names,
know = know) %>%
unnest(know) %>%
graph.data.frame(vertices = vrtcs)
graph
nodes <- c("x1", "x2", "x3", "x4", "x5")
edges <- list(x1 = c("x2"),
x2 = c("x4"),
x3 = c("x2"),
x4 = c("x3"),
x5 = c("x4"))
graph.data.frame(data.frame(nodes, edges))
data.frame(nodes, edges)
tibble(nodes, edges)
tibble(nodes, edges) |>
unnest(edges) |>
graph.data.frame()
tibble(nodes, edges) |>
unnest(edges) |>
graph.data.frame() |>
plot()
tibble(nodes, edges) |>
unnest(edges) |>
graph.data.frame() |>
plot()
g <- tibble(nodes, edges) |>
unnest(edges) |>
graph.data.frame()
l <- layout.fruchterman.reingold(g)
plot(g)
l <- matrix(c(-1, 2,
-1, 1,
0, 0,
1, 1,
1, 2),
nrow = 2,
byrow = T)
plot.igraph(g, layout = l)
plot.igraph(g, layout = l)
l <- matrix(c(-1, 2,
-1, 1,
0, 0,
1, 1,
1, 2),
ncol = 2,
byrow = T)
plot.igraph(g, layout = l)
plot.igraph(g,
edge.arrow.size = 0.2,
layout = l)
plot.igraph(g,
edge.arrow.size = 0.2,
edge.arrow.col = "blue",
layout = l)
plot.igraph(g,
edge.arrow.size = 0.2,
edge.color = "blue",
layout = l)
plot.igraph(g,
vertex.color = "white",
edge.arrow.size = 0.2,
edge.color = "blue",
layout = l)
col <- c("blue", "lightblue", "lightblue", "blue", "darkblue")
plot.igraph(g,
vertex.color = "white",
edge.arrow.size = 0.2,
edge.color = col,
layout = l)
nodes <- c("X1", "X2", "X3", "X4", "X5")
edges <- list(x1 = c("x2"),
x2 = c("x4"),
x3 = c("x2"),
x4 = c("x3"),
x5 = c("x4"))
g <- tibble(nodes, edges) |>
unnest(edges) |>
graph.data.frame()
l <- matrix(c(-1, 2,
-1, 1,
0, 0,
1, 1,
1, 2),
ncol = 2,
byrow = T)
col <- c("blue", "lightblue", "lightblue", "blue", "darkblue")
plot.igraph(g,
vertex.color = "white",
edge.arrow.size = 0.2,
edge.color = col,
layout = l)
edges <- list(X1 = c("X2"),
X2 = c("X4"),
X3 = c("X2"),
X4 = c("X3"),
X5 = c("X4"))
g <- tibble(nodes, edges) |>
unnest(edges) |>
graph.data.frame()
l <- matrix(c(-1, 2,
-1, 1,
0, 0,
1, 1,
1, 2),
ncol = 2,
byrow = T)
col <- c("blue", "lightblue", "lightblue", "blue", "darkblue")
plot.igraph(g,
vertex.color = "white",
edge.arrow.size = 0.2,
edge.color = col,
layout = l)
edges2 <- list(X1 = c("X2", "X3"),
X2 = c("X3", "X4"),
X3 = c("X2", "X4"),
X4 = c("X2", "X3"),
X5 = c("X2", "X4"))
g2 <- tibble(nodes, edges2) |>
unnest(edges2) |>
graph.data.frame()
plot.igraph(g2,
vertex.color = "white",
edge.arrow.size = 0.2,
edge.color = col)
plot.igraph(g2,
vertex.color = "white",
edge.arrow.size = 0.2,
edge.color = col)
plot.igraph(g2,
vertex.color = "white",
edge.arrow.size = 0.2,
edge.color = "blue",
layout = l)
reprex::reprex()
reprex::reprex()
reprex::reprex()
reprex::reprex(wd = "../..")
reprex::reprex(wd = "../..")
reprex::reprex(wd = "../..", venue = "html")
